defmodule EulerProblem1 do
  @doc ~S"""
  If we list all the natural numbers below 10 that are multiples of 3 or 5,
  we get 3, 5, 6 and 9. The sum of these multiples is 23.

  Find the sum of all the multiples of 3 or 5 below 1000.
  """
  def solve do
    max_num = 1000
    sum = Enum.sum(Enum.filter(1..(max_num - 1), fn x -> rem(x, 3) == 0 || rem(x, 5) == 0 end))
    IO.puts(sum)
  end
end

defmodule EulerProblem2 do
  @doc ~S"""
  Each new term in the Fibonacci sequence is generated by adding the previous two terms.
  By starting with 1 and 2, the first 10 terms will be:

  1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

  By considering the terms in the Fibonacci sequence whose values do not exceed four million,
  find the sum of the even-valued terms.
  """
  def solve do
    max_num = 4_000_000

    fib_seq_to_max_val(max_num)
    |> Enum.filter(fn x -> rem(x, 2) == 0 && x < max_num end)
    |> Enum.sum()
  end

  defp fib_seq_to_max_val(max_val, current_seq \\ []) do
    len_seq = length(current_seq)

    next_val =
      case len_seq do
        0 -> 0
        1 -> 1
        _ -> Enum.at(current_seq, 0) + Enum.at(current_seq, 1)
      end

    if next_val >= max_val do
      current_seq
    else
      fib_seq_to_max_val(max_val, [next_val | current_seq])
    end
  end
end

defmodule EulerProblem3 do
  @doc ~S"""
  The prime factors of 13195 are 5, 7, 13 and 29.

  What is the largest prime factor of the number 600851475143 ?

  Solution source: https://github.com/steven-s/prime_factors_elixir/blob/master/lib/prime_factors.ex
  """
  def solve do
    num_to_factor = 600_851_475_143
    # num_to_factor = 1

    largest_prime =
      generate(num_to_factor)
      |> Enum.reduce(&max/2)

    IO.puts(largest_prime)
  end

  defp generate(num) do
    if num == 1 do
      # 1 is the only factor of 1
      generate(num, 2, [1])
    else
      generate(num, 2, [])
    end
  end

  defp generate(1, _, acc) do
    acc
  end

  defp generate(num, candidate, acc) when rem(num, candidate) == 0 do
    generate(div(num, candidate), candidate, [candidate | acc])
  end

  defp generate(num, candidate, acc) do
    generate(num, candidate + 1, acc)
  end
end

defmodule EulerProblem4 do
  @doc """
  A palindromic number reads the same both ways.
  The largest palindrome made from the product of
  two 2-digit numbers is 9009 = 91 Ã— 99.

  Find the largest palindrome made from the product of two 3-digit numbers.
  """
  def solve do
    num_list = Enum.map(999..100, fn x -> check_products(x) end)
    # IO.inspect(num_list[-1])
    # if palindrome?(largest_product) do
    #   factors = factor(largest_product)
    # else do
    # end

    # IO.puts(palindrome?(largest_product))
  end

  defp check_products(num1) do
    Enum.map((num1 - 1)..100, fn x ->
      if palindrome?(num1 * x) do
        IO.puts(to_string(num1) <> " " <> to_string(x) <> " " <> to_string(num1 * x))
      end
    end)

    # IO.puts(num1)
  end

  defp factor(number) do
    :ignore
  end

  defp palindrome?(string) do
    list = string |> to_char_list |> normalize
    list == :lists.reverse(list)
  end

  defp normalize(char_list),
    do: char_list |> Enum.map(&normalize_char/1) |> Enum.reject(&(&1 == :ignore))

  defp normalize_char(char) when char in ?a..?z, do: char
  defp normalize_char(char) when char in ?0..?9, do: char
  defp normalize_char(char) when char in ?A..?Z, do: char + ?a - ?A
  defp normalize_char(_char), do: :ignoreend
end

EulerProblem4.solve()
