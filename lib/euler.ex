defmodule EulerProblem1 do
  @doc ~S"""
  If we list all the natural numbers below 10 that are multiples of 3 or 5,
  we get 3, 5, 6 and 9. The sum of these multiples is 23.

  Find the sum of all the multiples of 3 or 5 below 1000.
  """
  def solve do
    max_num = 1000
    sum = Enum.sum(Enum.filter(1..(max_num - 1), fn x -> rem(x, 3) == 0 || rem(x, 5) == 0 end))
    IO.puts(sum)
  end
end

defmodule EulerProblem2 do
  @doc ~S"""
  Each new term in the Fibonacci sequence is generated by adding the previous two terms.
  By starting with 1 and 2, the first 10 terms will be:

  1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

  By considering the terms in the Fibonacci sequence whose values do not exceed four million,
  find the sum of the even-valued terms.
  """
  def solve do
    max_num = 4_000_000

    fib_seq_to_max_val(max_num)
    |> Enum.filter(fn x -> rem(x, 2) == 0 && x < max_num end)
    |> Enum.sum()
  end

  defp fib_seq_to_max_val(max_val, current_seq \\ []) do
    len_seq = length(current_seq)

    next_val =
      case len_seq do
        0 -> 0
        1 -> 1
        _ -> Enum.at(current_seq, 0) + Enum.at(current_seq, 1)
      end

    if next_val >= max_val do
      current_seq
    else
      fib_seq_to_max_val(max_val, [next_val | current_seq])
    end
  end
end

defmodule EulerProblem3 do
  @doc ~S"""
  The prime factors of 13195 are 5, 7, 13 and 29.

  What is the largest prime factor of the number 600851475143 ?

  Solution source: https://github.com/steven-s/prime_factors_elixir/blob/master/lib/prime_factors.ex
  """
  def solve do
    num_to_factor = 600_851_475_143
    # num_to_factor = 1

    largest_prime =
      generate(num_to_factor)
      |> Enum.reduce(&max/2)

    IO.puts(largest_prime)
  end

  defp generate(num) do
    if num == 1 do
      # 1 is the only factor of 1
      generate(num, 2, [1])
    else
      generate(num, 2, [])
    end
  end

  defp generate(1, _, acc) do
    acc
  end

  defp generate(num, candidate, acc) when rem(num, candidate) == 0 do
    generate(div(num, candidate), candidate, [candidate | acc])
  end

  defp generate(num, candidate, acc) do
    generate(num, candidate + 1, acc)
  end
end

defmodule EulerProblem4 do
  @doc """
  A palindromic number reads the same both ways.
  The largest palindrome made from the product of
  two 2-digit numbers is 9009 = 91 Ã— 99.

  Find the largest palindrome made from the product of two 3-digit numbers.
  """
  def solve do
    largest_palindrome =
      Enum.map(
        999..100,
        fn x -> find_palindrome_products(x) end
      )
      |> Enum.filter(fn x -> x != [] end)
      |> List.flatten()
      |> Enum.reduce(&max/2)

    IO.puts(largest_palindrome)
  end

  defp find_palindrome_products(num1) do
    Enum.map(
      num1..100,
      fn x -> check_product(num1, x) end
    )
    |> Enum.reject(&is_nil/1)
  end

  defp check_product(num1, num2) do
    product = num1 * num2

    if palindrome?(product) do
      product
    end
  end

  defp palindrome?(string) do
    list = string |> Kernel.to_charlist()
    list == :lists.reverse(list)
  end
end

EulerProblem4.solve()
